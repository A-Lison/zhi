## JS高级-闭包

### 理解闭包

 // 关于闭包的理解

​    // *内部嵌套函数引用外部函数的数据

​    // 注：闭包存在于嵌套的内部函数中



​    // 闭包产生的条件

​    // *函数嵌套

​    // *内部嵌套函数引用外部函数的数据（变量/函数）



​    // 闭包的作用

​    // 1.延长局部变量的生命周期（执行完函数后，变量仍存活）

​    // 2.让函数外部可以操作（读写）到函数内部的数据（变量、函数）

```
   function fn1() {

​      var a = 2;



​      function fn2() { //执行函数定义

​        console.log(a);

​      }

​      fn2();

​    }

​    fn1();
```

### 闭包的应用

// 应用：

​    // 具有特定功能的js文件

​    // 将所有数据和功能都封装在一个函数内部（私有的）

​    // 只向外暴露一个包含n个方法的对象或函数

​    // 通过模块暴露的对象调用方法来实现对应的功能

```

//第一种应用
function box() {
    //私有数据
    var a = 'my world';
    //操作数据的函数
    function dosomething() {
        console.log('dosomething()' + a.toUpperCase());
    }

    function dootherthing(params) {
        console.log(a.toLowerCase());
    }
    // return dosomething;
    //向外暴露函数对象
    return {
        dosomething: dosomething,
        dootherthing: dootherthing
    }
}
         var f = box();
        f.dootherthing();
        f.dosomething();
//第二种应用
(function box() {
    //私有数据
    var a = 'my world';
    //操作数据的函数
    function dosomething() {
        console.log('dosomething()' + a.toUpperCase());
    }

    function dootherthing(params) {
        console.log(a.toLowerCase());
    }
    // return dosomething;
    //向外暴露函数对象
    window.封装闭包2 = {
        dosomething: dosomething,
        dootherthing: dootherthing
    }
})()
        封装闭包2.dootherthing();
        封装闭包2.dosomething();
```

### 闭包的生命周期

 // 产生：执行完函数定义时已产生

​    // 死亡：内部函数成为垃圾对象时死亡

```
function fn1() {
            var a = 2; //此时闭包已经产生

            // var fn2 = function() { //如此定义，闭包此时才产生

            //     console.log(a);
            // }
            // return fn2;

            function fn2() {
                a = 3;
                console.log(a);
            }
            return fn2;
        }
        var f = fn1();
        f();
        // f = null; //闭包死亡
        f();
```

### 常见的闭包

```
  function fn1() {
            var a = 2;

            function fn2() {
                a++;
                console.log(a);
            }
            return fn2;
        }
        var f = fn1();
        f();
        f();

        function delay(msg, time) {
            setTimeout(function() {
                alert(msg);
            }, time);
        }
        delay('time out', 2000);
```

## JS基础-对象

### 利用new object创建函数对象

```
 var obj = new Object;
        obj.name = '鸣人';
        obj.sex = '男';
        obj.age = 19;
        obj.skill = function() {
            console.log('影分身术');
        }
        console.log(obj.name);
        obj.skill();
```

### 利用对象创建函数字面量简介

```
 var obj = {
                name: '可可',
                type: '阿拉斯加犬',
                age: 25,
                color: 'red - brown',
                skill: function() {
                    alert('bark');
                },
                fn: function() {
                    alert('hello');
                }
            }
            //调用对象属性 两种
        console.log(obj.name);
        //对象名['属性']
        console.log(obj['age']);

        // 调用对象方法
        obj.skill();
        obj.fn();
```

### 构造函数（封装）

```
 function Hero(uname, type, life, skill) {
            this.name = uname;
            this.type = type;
            this.life = life;
            this.skill = function ski() {
                alert(skill);
            }
        }
        var lp = new Hero('廉颇', '力量型', 500, '近战'); //调用函数返回一个对象
        console.log(lp.name);
        console.log(lp['life']);
        lp.skill();
        var hy = new Hero('后裔', '射手型', 100, '远程');
        hy.skill();
```

### 遍历对象

```
var obj = {
            name: '张三',
            age: 67,
            sex: '女'
        }
        for (var k in obj) {
            console.log(k); //返回属性名
            console.log(obj[k]); //返回属性内容
        }
```

## JS基础-函数

### arguments的使用

```
function name(params) {
            console.log(arguments[1]); //arguments里面存储了所有传过来的实参
        }
        name(1, 2, 43);
        // arguments是一个伪数组 arguments.length可求实参长度
        //arguments没有数组的pop() push()

        function fn1(params) {
            return arguments;
        }
        console.log(fn1(1, 2, 3));
```

### 函数变量

```
function fn1() {
            var a = 2;
            console.log(a);

            function fn2() {
                console.log(a);
            }
            fn2();
        }
        fn1();
```

### 带参数的函数

```
 function cook() {
            console.log('酸辣土豆丝');
        }
        cook();
        cook();
        // 传参执行函数
        function name(params) {
            console.log(params);
        }
        name('烤冷面');
        // 形参与实参不匹配问题
        function sum(num1, num2) {
            console.log(num1 + num2);

        }
        sum(1, 2); //3
        sum(1, 2, 3); //3 结果取到形参个数
        sum(1); //num2没有接收值，为undefined,undefined+任何数字都为NaN
```

### 函数的返回

```
function cook(aru) {
            return aru;
            alert('不会被执行！'); //return后面的代码不会被执行
        }
        console.log(cook('大肘子'));

        function sum() {
            // return 1, 2, 3; //return只能返回一个值，若有多个值，则以最后一个值为准
            return [1, 2, 3]; //return只能返回一个值，若有多个值，则以最后一个值为准

        }
        console.log(sum());

        function fn1() {

            return;

        }
        console.log(fn1()); //函数无返回值，输出undefined
```

### 函数封装冒泡排序

```
 function sort(arr) {
            for (var i = 0; i < arr.length - 1; i++) {
                for (var j = 0; j < arr.length - i - 1; j++) {
                    if (arr[j] > arr[j + 1]) {
                        var temp = 0;
                        temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }

                }

            }
            return arr;
        }
        console.log(sort([1, 5, 8, 4]));
```

