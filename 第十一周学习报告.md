## JS高阶-原型

### 函数的prototype

#### 代码

```
console.log(Date.prototype, typeof Date.prototype);

        function fun() {

        }
        fun.prototype.test = function() {

                console.log('test()');
            }
            // fun();
        console.log(fun.prototype);
```

#### 显式原型与隐式原型                                                                                                                                                                                     

#### 结构图

![image-20210516141553191](C:\Users\555\AppData\Roaming\Typora\typora-user-images\image-20210516141553191.png)

#### 代码与解释

注：prototype属性：定义函数时添加的，默认值为一个空的object对象

​    __proto__属性：创建对象时添加的，默认值为prototype属性值（即prototype的地址）

​    不可直接操作隐式原型

```
//（1）创建显式函数对象
        function Fn() { //内部语句：this.prototype={}

        }
        //每个函数内部都有一个prototype属性，默认指向一个空的object对象
        console.log(Fn.prototype);
        //每个实例对象都有一个隐式原型，__proto__
        var fn = new Fn();
        console.log(fn.__proto__);
        //验证 隐式原型的值为其对应构造函数显式原型的值
        console.log(Fn.prototype === fn.__proto__);

        //（2）添加显式原型实例对象方法
        Fn.prototype.test = function() {
                console.log("test()");
            }
            //调用方法
        fn.test();
```

### 原型链

#### 结构图

![image-20210516141749295](C:\Users\555\AppData\Roaming\Typora\typora-user-images\image-20210516141749295.png)

#### 代码与解释

1.所有函数_proto_都是一样的，都由new Function()产生

2.实例对象的隐式原型等于构造函数的显式原型

```
function Fn() {
            this.test1 = function() {
                console.log('test1()');
            }
        }
        Fn.prototype = {
                constructor: person,
                run: function() {
                    alert("我也不知道是什么");
                }
            }
            //通过prototype原型给函数内部添加方法
        Fn.prototype.test2 = function() {

            console.log('test2()');
        }

        //注： Fn.test1();无法执行内部事件
        Fn.prototype.test2();
        var fn = new Fn(); //获取Fn内部实例对象
        fn.test1();
        fn.test2();
        console.log(fn.toString());
        // fn.test3(); //未添加的方法
```

​    **关系：在本代码中，实例对象是fn ; 构造函数是Fn ; 原型对象是Fn.peototype** 

> ​    1： 实例对象和构造函数之间的关系：

​    构造函数就是母亲(理解为蓝图也可以)；

​    new就是生产过程；

​    实例对象就是孩子；

​    所以实例对象和构造函数就是一种“ 生产关系”

> ​    2： 实例对象和原型对象的关系：

​    每个实例对象有一个隐式原型(_proto_)；

​    构造函数的原型对象是(Fn.prototype)；‘

​    实例对象的隐式原型(_proto_) 指向原型对象的显式原型(Fn.prototype）， 是是一种“ 委托“ 关系。 

> ​     3: 构造函数和原型对象的关系： 

​     首先， 函数的三大作用：

​     [1].封装可复用逻辑代码段

​     [2].作为可以new的构造函数

​     [3].本身是对象 因为构造函数本身也是对象， 那么函数就有两个原型。

​     person.prototype此原型是给person的实例用的。 

​     person._proto_是给自己用的。

补充：

```
 //1.验证函数的显式原型是不是一个空object的对象
                console.log(Fn.prototype instanceof Object); //ture
                console.log(Object.prototype instanceof Object); //false
                console.log(Function.prototype instanceof Object); //ture
                //2. 所有函数的实例对象是Function（包括Funcion本身）
                //3.Object的原型对象是原型链的尽头
                console.log(Object.prototype._proto_ === null);
```

### instanceof

表达式：A instanceof B      A 是实例函数对象，B是构造函数

### 一个常用的封装函数（藏）

编写一个`createStudent()`函数，在内部封装所有的`new`操作

```javascript
function Student(props) {
    this.name = props.name || '匿名'; // 默认值为'匿名'
    this.grade = props.grade || 1; // 默认值为1
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');//注意输出字符串的语法格式
};

function createStudent(props) {
    return new Student(props || {})
}
```

这个`createStudent()`函数有几个巨大的优点：一是不需要`new`来调用，二是参数非常灵活，可以不传，也可以这么传：

```
var xiaoming = createStudent({
    name: '小明'
});

xiaoming.grade; // 1
```

# onbeforeunload 事件

#### 定义与使用方法

**定义：onbeforeunload 事件在即将离开当前页面（刷新或关闭）时触发。**

**该事件可用于弹出对话框，提示用户是继续浏览页面还是离开当前页面。**

1.向 body 元素添加 "onbeforeunload" 事件。

```
<body onbeforeunload="return myFunction()">
<script>
function myFunction() {
    return "我在这写点东西...";
}
</script>

</body>
```

2.使用 HTML DOM 向 body 元素添加 "onbeforeunload" 事件。

```
<body>

<script>
window.onbeforeunload = function(event) {
    event.returnValue = "我在这写点东西...";
};
</script>

</body>
```

3.使用 addEventListener() 方法向 body 元素添加 "onbeforeunload" 事件。

```
<body>

<script>
window.addEventListener("beforeunload", function(event) {
    event.returnValue = "我在这写点东西...";
});
</script>

</body>
```

#### 记录停留时长（藏）

```javascript
(function(){
    var startTime = Math.ceil(new Date().getTime()/1000), //单位秒
        getDuration = function(){
            var time = '',
                hours = 0,
                minutes = 0,
                seconds = 0,
                endTime = Math.ceil(new Date().getTime()/1000),
                duration = endTime - startTime;

            hours = Math.floor(duration/3600); //停留小时数
            minutes = Math.floor(duration%3600/60); //停留分钟数
            seconds = Math.floor(duration%3600%60); //停留秒数

            time = (hours < 10 ? '0' + hours : hours) + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);

            return time;
        };        


    window.onbeforeunload = function(e){
        var duration = getDuration();

        //request(duration);
    };
})
```

